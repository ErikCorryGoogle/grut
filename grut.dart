import "dart:io";
import "dart:math";

class State {
  State(this.out);
  IOSink out;
  int captures = 0;
  int counters = 0;
  int zeroChecks = 0;

  // A capture, counter or zero check can be represented by an integer.  Encode
  // and decode those integers.
  int captureRepresentation(int x) => x;
  int counterRepresentation(int x) => x + captures;
  int zeroCheckRepresentation(int x) => x + captures + counters;
  bool isCaptureRepresentation(int x) => x < captures;
  bool isCounterRepresentation(int x) => x < captures + counters && x >= captures;
  bool isZeroCheckRepresentation(int x) => x >= captures + counters;
  int getCapture(int x) => x;
  int getCounter(int x) => x - captures;
  int getZeroCheck(int x) => x - captures - counters;
}

abstract class Ast {
  Ast(this.backwards);
  static int ctr = 0;
  String name = "f${ctr++}";
  int get minWidth;
  int get maxWidth;
  int get minCharWidth;
  int get maxCharWidth;
  bool get simple => false;
  bool backwards = false;
  void collect(State s, List<int> regs, bool goIntoLoops) {}

  factory Ast.literalCode(int unicode, bool backwards) {
    bool b = backwards;
    if (unicode < 0x80) {
      if ((unicode >= 'a'.codeUnitAt(0) && unicode <= 'z'.codeUnitAt(0)) ||
          (unicode >= 'A'.codeUnitAt(0) && unicode <= 'Z'.codeUnitAt(0)) ||
          (unicode >= '0'.codeUnitAt(0) && unicode <= '9'.codeUnitAt(0)) ||
          unicode == ' '.codeUnitAt(0)) {
        return new Literal(new String.fromCharCode(unicode), b);
      } else if (unicode >= ' '.codeUnitAt(0)) {
        return new Literal.named(unicode, '\\${new String.fromCharCode(unicode)}', b);
      } else {
        return new Literal.hex(unicode, b);
      }
    } else if (unicode < 0x800) {
      Ast part1 = new Literal.hex(0xc0 + (unicode >> 6), b);
      Ast part2 = new Literal.hex(0x80 + (unicode & 0x3f), b);
      if (b)
        return new Alternative(part2, part1, b);
      else
        return new Alternative(part1, part2, b);
    } else if (unicode < 0x10000) {
      Ast part1 = new Literal.hex(0xe0 + (unicode >> 12), b);
      Ast part2 = new Literal.hex(0x80 + ((unicode >> 6) & 0x3f), b);
      Ast part3 = new Literal.hex(0x80 + (unicode & 0x3f), b);
      if (b)
        return new Alternative(new Alternative(part3, part2, b), part1, b);
      else
        return new Alternative(new Alternative(part1, part2, b), part3, b);
    } else {
      Ast part1 = new Literal.hex(0xf0 + (unicode >> 18), b);
      Ast part2 = new Literal.hex(0x80 + ((unicode >> 12) & 0x3f), b);
      Ast part3 = new Literal.hex(0x80 + ((unicode >> 6) & 0x3f), b);
      Ast part4 = new Literal.hex(0x80 + (unicode & 0x3f), b);
      if (b)
        return new Alternative(new Alternative(new Alternative(part4, part3, b), part2, b), part1, b);
      else
        return new Alternative(new Alternative(new Alternative(part1, part2, b), part3, b), part4, b);
    }
  }

  void _(State state, Object o) {
    state.out.writeln(o);
  }

  // Prints the dot-file (graphviz) output for each AST node.
  void dump() {
    String s = toString();
    if (!(s is String)) throw "toString failure: $s";
    // Escape for .dot format.
    if (s.contains("\\") || s.contains('"'))
      s = s.replaceAllMapped(new RegExp(r'[\\"]'), (m) => "\\${m[0]}");
    print('"$name" [label="$s"];');
  }
  // Prints the .ll (LLVM ASCII bitcode) code for this node.  Each regexp AST
  // node is code-generated by creating one function, though LLVM will later
  // inline a lot of the trivial ones.
  void gen(State state, String successor);
  // Generate a function called name_backtrack. Can only be asked to backtrack
  // over valid data it already advanced over.  Gets no state.  Will only be
  // called on simple nodes.
  void genBacktrack(State s) { throw "Can't backtrack non-simple nodes"; }
  // For each AST node, determines how many registers (slots of storage in the
  // state) we are going to need when code generating.
  void alloc(State state) {}
  bool isAnchored() => false;
  // Utility function used by gen.  Merely calls a different function and
  // returns whatever that function returns.
  void forward(State s, String type, String from, String to) {
    _(s, "define internal $type @$from(%restate_t* %state, i8* %s) {");
    _(s, "  %result = call $type @$to(%restate_t* %state, i8* %s)");
    _(s, "  ret $type %result");
    _(s, "}");
  }
  // If we are in continuation mode (the successor is passed to us)
  // then we check for failure by checking for a zero result.
  // If we are in call-return mode, then we return < 0 for failure (> 0 if the
  // regexp is in backwards mode inside a lookbehind).
  String check_for_failure(String succ) {
    if (succ != null) return "icmp eq i32 0,";
    if (backwards) return "icmp slt i32 0,";
    return "icmp sgt i32 0,";
  }
  int failure_code(String succ) {
    if (succ != null) return 0;
    if (backwards) return 1;
    return -1;
  }
  String get compare_failure => "icmp eq i32 0,";
}

abstract class BinaryAst extends Ast {
  BinaryAst(this.l, this.r, bool backwards) : super(backwards);
  Ast l, r;
  int minWidthCached;
  int maxWidthCached;
  bool maxWidthIsCalculated = false;
  int minCharWidthCached;
  int maxCharWidthCached;
  bool maxCharWidthIsCalculated = false;

  void dump() {
    super.dump();
    print('"$name" -> "${l.name}";');
    print('"$name" -> "${r.name}";');
    l.dump();
    r.dump();
  }
  void alloc(State state) {
    l.alloc(state);
    r.alloc(state);
  }
  void collect(State s, List<int> regs, bool goIntoLoops) {
    l.collect(s, regs, goIntoLoops);
    r.collect(s, regs, goIntoLoops);
  }
}

abstract class Macro extends Ast {
  Macro(this.implementation, bool backwards) : super(backwards);
  Ast implementation;
  void gen(State s, String succ) {
    forward(s, "i32", name, implementation.name);
    implementation.gen(s, succ);
  }
  int get minWidth => implementation.minWidth;
  int get maxWidth => implementation.maxWidth;
  int get minCharWidth => implementation.minCharWidth;
  int get maxCharWidth => implementation.maxCharWidth;
  String toString();
}

// Does not accept any overlong encodings, since that can be a security issue.
class Utf8Dot extends Macro {
  Utf8Dot(bool backwards) : super(null, backwards) {
    Ast ascii = new CharacterClass(backwards)..addNumeric(1, 0x7f);
    // Using c2 as the start exactly excludes all the ASCII two-byte overlong
    // encodings, which all start with c0 or c1.
    Ast twoByte1 = new CharacterClass(backwards)..addNumeric(0xc2, 0xdf);
    Ast trail = new CharacterClass(backwards)..addNumeric(0x80, 0xbf);
    bool b = backwards;;
    if (!backwards) {
      // The 4-byte encoding could go to 0xf7, but 0xf5 and above take us
      // beyond the 0x10ffff Unicode limit.
      Ast threeOrFourStart = new CharacterClass(b)..addNumeric(0xe0, 0xf4);
      Ast inlineCheck = new Lookahead(threeOrFourStart, b, true);
      Ast threeOrFour =
	  new Alternative(inlineCheck, new ThreeOrFourByteUtf8(), b);
      Alternative twoByte = new Alternative(twoByte1, trail, b);
      implementation = new Disjunction(new Disjunction(ascii, twoByte, b), threeOrFour, b);
    } else {
      Ast multi = new MultiByteBackwardsUtf8();
      // Positive lookbehind for a byte with the 10xxxxxx pattern, which would
      // be the last byte of a multi-byte sequence.
      Ast inlineCheck = new Lookahead(trail, b, true);
      implementation = new Disjunction(ascii, new Alternative(inlineCheck, multi, b), b);
    }
  }
  void genBacktrack(State s) {
    if (backwards) return genBacktrackBackwards(s);
    // Go back over one UTF-8 character.
    _(s, "define internal i8* @${name}_backtrack(%restate_t* %state, i8* %s) {");
    _(s, "  %prev = getelementptr i8, i8* %s, i32 -1");
    _(s, "  %c = load i8, i8* %prev, align 1");
    _(s, "  %top_bit = and i8 %c, 128");
    _(s, "  %comparison = icmp eq i8 0, %top_bit");
    _(s, "  br i1 %comparison, label %ascii, label %non_ascii");
    _(s, "ascii:");
    _(s, "  ret i8* %prev");
    _(s, "non_ascii:");
    // We have found the end of a UTF-8 non-ASCII sequence.  The trailing bytes
    // are 10xxxxxx and the first byte, which we are searching for is 11xxxxxx.
    _(s, "  %pos = phi i8* [ %prev, %0 ], [ %prev2, %non_ascii]");
    _(s, "  %prev2 = getelementptr i8, i8* %pos, i32 -1");
    _(s, "  %c2 = load i8, i8* %prev2, align 1");
    _(s, "  %second_bit = and i8 %c2, 64");
    _(s, "  %comparison2 = icmp eq i8 0, %second_bit");
    _(s, "  br i1 %comparison2, label %non_ascii, label %done");
    _(s, "done:");
    _(s, "  ret i8* %prev2");
    _(s, "}");
  }
  void genBacktrackBackwards(State s) {
    // Go forwards over one UTF-8 character.
    _(s, "define internal i8* @${name}_backtrack(%restate_t* %state, i8* %s) {");
    _(s, "  %c = load i8, i8* %s, align 1");
    _(s, "  %top_bit = and i8 %c, 128");
    _(s, "  %comparison = icmp eq i8 0, %top_bit");
    _(s, "  %next = getelementptr i8, i8* %s, i32 1");
    _(s, "  br i1 %comparison, label %ascii, label %non_ascii");
    _(s, "ascii:");
    _(s, "  ret i8* %next");
    _(s, "non_ascii:");
    // We have found the start of a UTF-8 non-ASCII sequence.  The trailing
    // bytes are 10xxxxxx and the first byte, which we are searching for is not
    // 10xxxxxx (it might be the null terminator).
    _(s, "  %pos = phi i8* [ %next, %0 ], [ %next2, %non_ascii]");
    _(s, "  %next2 = getelementptr i8, i8* %pos, i32 1");
    _(s, "  %c2 = load i8, i8* %next2, align 1");
    _(s, "  %top_bits = and i8 %c2, 192");
    _(s, "  %comparison2 = icmp eq i8 128, %top_bits");
    _(s, "  br i1 %comparison2, label %non_ascii, label %done");
    _(s, "done:");
    _(s, "  ret i8* %next2");
    _(s, "}");
  }
  String toString() {
    String b = backwards ? "⇐" : "";
    return "$b.";
  }
  int get minWidth => 1;
  int get maxWidth => 4;
  int get minCharWidth => 1;
  int get maxCharWidth => 1;
  bool get simple => true;
}

class ThreeOrFourByteUtf8 extends Ast {
  ThreeOrFourByteUtf8() : super(false);
  void gen(State s, String succ) {
    _(s, "define internal i32 @$name(%restate_t* %state, i8* %s) {");
    _(s, "  %result = call i32 @check3Or4Utf8(i8* %s)");
    _(s, "  %comparison = icmp eq i32 0, %result");
    _(s, "  br i1 %comparison, label %fail, label %success");
    _(s, "fail:");
    _(s, "  ret i32 ${failure_code(succ)}");
    _(s, "success:");
    if (succ == null) {
      _(s, "  ret i32 %result");
    } else {
      _(s, "  %next = getelementptr i8, i8* %s, i32 %result");
      _(s, "  %succ_result = call i32 @$succ(%restate_t* %state, i8* %next)");
      _(s, "  ret i32 %succ_result");
    }
    _(s, "}");
  }
  String toString() => "<3or4byteUTF8>";
  int get minWidth => 3;
  int get maxWidth => 4;
  int get minCharWidth => 1;
  int get maxCharWidth => 1;
  bool get simple => false;
}

class MultiByteBackwardsUtf8 extends Ast {
  MultiByteBackwardsUtf8() : super(true);
  void gen(State s, String succ) {
    _(s, "define internal i32 @$name(%restate_t* %state, i8* %s) {");
    _(s, "  %start_gep = getelementptr %restate_t, %restate_t* %state, i64 0, i32 0");
    _(s, "  %start = load i8*, i8** %start_gep");
    _(s, "  %result = call i32 @checkMultiByteBackwards(i8* %s, i8* %start)");
    _(s, "  %comparison = icmp eq i32 0, %result");
    _(s, "  br i1 %comparison, label %fail, label %success");
    _(s, "fail:");
    _(s, "  ret i32 ${failure_code(succ)}");
    _(s, "success:");
    if (succ == null) {
      _(s, "  ret i32 %result");
    } else {
      _(s, "  %next = getelementptr i8, i8* %s, i32 %result");
      _(s, "  %succ_result = call i32 @$succ(%restate_t* %state, i8* %next)");
      _(s, "  ret i32 %succ_result");
    }
    _(s, "}");
  }
  String toString() => "<multibytebackwards>";
  int get minWidth => 1;
  int get maxWidth => 4;
  int get minCharWidth => 1;
  int get maxCharWidth => 1;
  bool get simple => true;
}

// Non-UTF-8 matcher of any byte.
class Dot extends Single {
  Dot(bool backwards) : super(backwards);
  String get condition => "ne";
  int get code => 0;
  String toString() => ".";
  int get advance => backwards ? -1 : 1;
  int get offset => backwards ? -1 : 0;
  int get minWidth => 1;
  int get maxWidth => 1;
  int get minCharWidth => 1;
  // It's not really well defined how many UTF-8 characters a one-byte matcher
  // steps over.
  int get maxCharWidth => null;
}

class End extends Single {
  End(bool backwards) : super(backwards);
  String get condition => "eq";
  int get code => 0;  // Match null character at end of string.
  String toString() => "\$";
  int get advance => 0;  // Zero width '$' assertion does not advance.
  int get offset => 0;
  int get minWidth => 0;
  int get maxWidth => 0;
  int get minCharWidth => 0;
  int get maxCharWidth => 0;
}

class Literal extends Single {
  // Printable literal.
  Literal(String char, bool backwards) : super(backwards) {
    code = char.codeUnitAt(0);
    escaped = char;
  }
  // Sort-of printable literal.
  Literal.named(this.code, this.escaped, bool backwards) : super(backwards);
  // Unprintable literal UTF8 code unit.
  Literal.hex(this.code, bool backwards) : super(backwards) {
    escaped = "0x${code.toRadixString(16).padLeft(2, "0")}";
  }
  // See also Ast.literal for random Unicode code points.
  int code;
  String escaped;

  String get condition => "eq";
  String toString() => escaped;
  int get advance => backwards ? -1 : 1;
  int get offset => backwards ? -1 : 0;
  int get minWidth => 1;
  int get maxWidth => 1;
  int get minCharWidth => 1;
  int get maxCharWidth => 1;
}

class Range {
  Range(this.from, this.to);
  int from, to; // Inclusive;
  String toString() {
    if (from == to)
      return printable(from);
    return "${printable(from)}-${printable(to)}";
  }
  String printable(int code) {
    if (code == r"\".codeUnitAt(0)) return r"\\";
    if (code == "-".codeUnitAt(0)) return r"\-";
    if (code == "]".codeUnitAt(0)) return r"\]";
    if (code < " ".codeUnitAt(0) || code > "~".codeUnitAt(0)) {
      if (code < 0x100)
        return r"\x" + code.toRadixString(16).padLeft(2, "0");
      return r"\u" + code.toRadixString(16).padLeft(4, "0");
    }
    return new String.fromCharCode(code);
  }
}

class Backreference extends Ast {
  Backreference(this.ref, bool backwards, this.jsMode) : super(backwards);
  int ref;
  bool jsMode;
  String toString() => r'\$ref';
  int get minWidth => 0;
  int get maxWidth => null;
  int get minCharWidth => 0;
  int get maxCharWidth => null;
  void gen(State s, String successor) {
    // TODO: This isn't really how we report syntax errors.
    if (ref * 2 >= s.captures) throw "Backreference out of range: $ref";
    _(s, "define internal i32 @$name(%restate_t* %state, i8* %s) {");
    _(s, "  %start_gep = getelementptr %restate_t, %restate_t* %state, i64 0, i32 0");
    _(s, "  %start = load i8*, i8** %start_gep");
    _(s, "  %gep_open = getelementptr %restate_t, %restate_t* %state, i64 0, i32 1, i32 ${ref * 2}");
    _(s, "  %gep_close = getelementptr %restate_t, %restate_t* %state, i64 0, i32 1, i32 ${ref * 2 + 1}");
    _(s, "  %open = load i8*, i8** %gep_open");
    _(s, "  %close = load i8*, i8** %gep_close");
    _(s, "  %offset_return = alloca i32, align 4");
    _(s, "  %result = call i32 @checkBackref(i8* %s, i8* %open, i8* %close, i8* %start, "
         "  i32* %offset_return, i32 ${backwards ? 1 : 0}, i32 ${jsMode ? 1 : 0})");
    _(s, "  %comparison = icmp eq i32 0, %result");
    _(s, "  br i1 %comparison, label %fail, label %success");
    _(s, "fail:");
    _(s, "  ret i32 0");
    _(s, "success:");
    _(s, "  %offset = load i32, i32* %offset_return");
    _(s, "  %next = getelementptr i8, i8* %s, i32 %offset");
    _(s, "  %succ_result = call i32 @$successor(%restate_t* %state, i8* %next)");
    _(s, "  ret i32 %succ_result");
    _(s, "}");
  }
}

class CharacterClass extends Ast {
  CharacterClass(bool backwards) : super(backwards);
  CharacterClass.digit(bool backwards) : super(backwards) { add("0", "9"); }
  CharacterClass.word(bool backwards) : super(backwards) {
    add("0", "9");
    add("A", "Z");
    add("_", "_");
    add("a", "z");
  }
  CharacterClass.whiteSpace(bool backwards) : super(backwards) {
    add("\t", "\r");
    add(" ", " ");
  }
  factory CharacterClass.notDigit(bool backwards) {
    CharacterClass self = new CharacterClass.digit(backwards);
    self.negate();
    return self;
  }
  factory CharacterClass.notWord(bool backwards) {
    CharacterClass self = new CharacterClass.word(backwards);
    self.negate();
    return self;
  }
  factory CharacterClass.notWhiteSpace(bool backwards) {
    CharacterClass self = new CharacterClass.whiteSpace(backwards);
    self.negate();
    return self;
  }
  List<Range> ranges = new List<Range>();

  void add(String from, String to) {
    ranges.add(new Range(from.codeUnitAt(0), to.codeUnitAt(0)));
  }
  void addNumeric(int from, int to) {
    ranges.add(new Range(from, to));
  }
  void mergeIn(CharacterClass other) { ranges.addAll(other.ranges); }

  void sortMerge() {
    ranges.sort((a, b) => a.from - b.from);
    Set<int> to_be_removed;
    int prev = 0;
    for (int i = 1; i < ranges.length; i++) {
      if (ranges[prev].to >= ranges[i].from - 1) {
        if (to_be_removed == null) to_be_removed = new Set<int>();
        to_be_removed.add(i);
        ranges[prev].to = max(ranges[prev].to, ranges[i].to);
      } else {
        prev = i;
      }
    }
    if (to_be_removed != null) {
      List<Range> old = ranges;
      ranges = new List<Range>();
      for (int i = 0; i < old.length; i++)
        if (!to_be_removed.contains(i)) ranges.add(old[i]);
    }
  }

  void negate() {
    int endOfLast = 1;  // Even a negated character class cannot match a null character.
    List<Range> negated = [];
    for (Range range in ranges) {
      if (range.from > endOfLast) negated.add(new Range(endOfLast, range.from - 1));
      endOfLast = range.to + 1;
    }
    if (endOfLast < 0x110000) negated.add(new Range(endOfLast, 0x10ffff));
    ranges = negated;
  }

  void gen(State s, String succ) {
    _(s, "define internal i32 @$name(%restate_t* %state, i8* %s) {");
    if (backwards) {
      _(s, "  %start_gep = getelementptr %restate_t, %restate_t* %state, i64 0, i32 0");
      _(s, "  %start = load i8*, i8** %start_gep");
      _(s, "  %start_compare = icmp eq i8* %s, %start");
      _(s, "  br i1 %start_compare, label %char_loaded, label %load_char");
      _(s, "load_char:");
      _(s, "  %gep = getelementptr i8, i8* %s, i64 -1");
      _(s, "  %loaded_c = load i8, i8* %gep, align 1");
      _(s, "  br label %char_loaded");
      _(s, "char_loaded:");
      // Load 0 if we are at start, which can never match.
      _(s, "  %c = phi i8 [ %loaded_c, %load_char ], [ 0, %0]");
    } else {
      _(s, "  %c = load i8, i8* %s, align 1");
    }
    _(s, "  br label %top");
    _(s, "top:");
    for (int i = 0; i < ranges.length; i++) {
      Range r = ranges[i];
      _(s, "  %fromcomparison$i = icmp ult i8 %c, ${r.from}");
      _(s, "  br i1 %fromcomparison$i, label %fail$i, label %from$i");
      _(s, "fail$i:");
      _(s, "  ret i32 ${failure_code(succ)}");
      _(s, "from$i:");
      _(s, "  %tocomparison$i = icmp ugt i8 %c, ${r.to}");
      _(s, "  br i1 %tocomparison$i, label %next$i, label %matched");
      _(s, "next$i:");
    }
    _(s, "  ret i32 ${failure_code(succ)}");
    _(s, "matched:");
    if (succ == null) {
      _(s, "  ret i32 ${backwards ? -1 : 1}");
    } else {
      _(s, "  %next = getelementptr i8, i8* %s, i64 ${backwards ? -1 : 1}");
      _(s, "  %succ_result = call i32 @$succ(%restate_t* %state, i8* %next)");
      _(s, "  ret i32 %succ_result");
    }
    _(s, "}");
  }
  String toString() => "[${ranges.join()}]";
  int get minWidth => 1;
  int get maxWidth => 1;
  int get minCharWidth => 1;
  int get maxCharWidth => 1;
  bool get simple => false;
}

class Start extends Ast {
  Start(bool backwards) : super(backwards);
  String toString() => "^";
  void gen(State s, String successor) {
    _(s, "define internal i32 @$name(%restate_t* %state, i8* %s) {");
    _(s, "  %start_gep = getelementptr %restate_t, %restate_t* %state, i64 0, i32 0");
    _(s, "  %start = load i8*, i8** %start_gep");
    _(s, "  %comparison = icmp eq i8* %s, %start");
    _(s, "  br i1 %comparison, label %matched, label %fail");
    _(s, "matched:");
    _(s, "  %succ_result = call i32 @$successor(%restate_t* %state, i8* %s)");
    _(s, "  ret i32 %succ_result");
    _(s, "fail:");
    _(s, "  ret i32 0");
    _(s, "}");
  }
  bool isAnchored() => true;
  int get minWidth => 0;
  int get maxWidth => 0;
  int get minCharWidth => 0;
  int get maxCharWidth => 0;
  // Even though it is simple there's no benefit from being able to generate it
  // in a simple loop.
  bool get simple => false;
}

// Single char superclass.
abstract class Single extends Ast {
  Single(bool backwards) : super(backwards);
  String get condition;
  int get code;
  int get advance;
  int get offset;

  void gen(State s, String succ) {
    _(s, "define internal i32 @$name(%restate_t* %state, i8* %s) {");
    // char c = *s
    if (offset == -1) {
      // When stepping backwards we have to check for start-of-string before
      // loading 1 character before the cursor.
      _(s, "  %start_gep = getelementptr %restate_t, %restate_t* %state, i64 0, i32 0");
      _(s, "  %start = load i8*, i8** %start_gep");
      _(s, "  %start_compare = icmp eq i8* %s, %start");
      _(s, "  br i1 %start_compare, label %at_start, label %load_char");
      _(s, "at_start:");
      _(s, "  ret i32 ${failure_code(succ)}");
      _(s, "load_char:");
      _(s, "  %gep = getelementptr i8, i8* %s, i64 $offset");
      _(s, "  %c = load i8, i8* %gep, align 1");
    } else {
      _(s, "  br label %load_char");
      _(s, "load_char:");
      _(s, "  %c = load i8, i8* %s, align 1");
    }
    _(s, "  %comparison = icmp $condition i8 %c, $code");
    _(s, "  br i1 %comparison, label %matched, label %no_match");
    _(s, "no_match:");
    _(s, "  ret i32 ${failure_code(succ)}");
    _(s, "matched:");
    if (succ == null) {
      _(s, "  ret i32 $advance");  // Width indicating success.
      _(s, "}");
      return;
    }
    _(s, "  %next = getelementptr i8, i8* %s, i64 $advance");
    _(s, "  %succ_result = call i32 @$succ(%restate_t* %state, i8* %next)");
    _(s, "  ret i32 %succ_result");
    _(s, "}");
  }
  void genBacktrack(State s) {
    _(s, "define internal i8* @${name}_backtrack(%restate_t* %state, i8* %s) {");
    _(s, "  %next = getelementptr i8, i8* %s, i64 ${-advance}");
    _(s, "  ret i8* %next");
    _(s, "}");
  }
  bool get simple => true;
}

// A series of terms matched one after the other.
class Alternative extends BinaryAst {
  Alternative(Ast l, Ast r, bool backwards) : super(l, r, backwards);

  String toString() => "(${backwards ? '←' : ''}$l$r)";
  void gen(State s, String succ) {
    if (succ != null) {
      forward(s, "i32", name, l.name);
      l.gen(s, r.name);
      r.gen(s, succ);
    } else {
      _(s, 'define internal i32 @$name(%restate_t* %state, i8* %s) {');
      _(s, '  %left = call i32 @${l.name}(%restate_t* %state, i8* %s)');
      _(s, '  %comparison = ${check_for_failure(succ)} %left');
      _(s, '  br i1 %comparison, label %left_failed, label %left_succeded');
      _(s, 'left_failed:');
      _(s, '  ret i32 %left');
      _(s, 'left_succeded:');
      // In this mode we return the number of characters matched if we succeed.
      _(s, "  %next = getelementptr i8, i8* %s, i32 %left");
      _(s, '  %right = call i32 @${r.name}(%restate_t* %state, i8* %next)');
      _(s, '  %comparison2 = ${check_for_failure(succ)} %right');
      _(s, '  br i1 %comparison2, label %right_failed, label %right_succeded');
      _(s, 'right_failed:');
      _(s, '  ret i32 %right');
      _(s, 'right_succeded:');
      _(s, '  %sum = add i32 %left, %right');
      _(s, '  ret i32 %sum');
      _(s, "}");
      l.gen(s, null);
      r.gen(s, null);
    }
  }
  void genBacktrack(State s) {
    _(s, "define internal i8* @${name}_backtrack(%restate_t* %state, i8* %s) {");
    _(s, '  %prev = call i8* @${l.name}_backtrack(%restate_t* %state, i8* %s)');
    _(s, '  %prev2 = call i8* @${r.name}_backtrack(%restate_t* %state, i8* %prev)');
    _(s, "  ret i8* %prev2");
    _(s, "}");
    l.genBacktrack(s);
    r.genBacktrack(s);
  }
  bool isAnchored() {
    if (l.maxWidth == 0) return l.isAnchored() || r.isAnchored();
    return l.isAnchored();
  }
  void alloc(State state) {
    // We have to do this to get the captures numbered correctly from left to
    // right in the source.
    if (backwards) {
      r.alloc(state);
      l.alloc(state);
    } else {
      l.alloc(state);
      r.alloc(state);
    }
  }
  int get minWidth {
    if (minWidthCached != null) return minWidthCached;
    return minWidthCached = l.minWidth + r.minWidth;
  }
  int get maxWidth {
    if (maxWidthIsCalculated) return maxWidthCached;
    maxWidthIsCalculated = true;
    int rw = r.maxWidth;
    if (rw == null) return null;
    int lw = l.maxWidth;
    if (lw == null) return null;
    return maxWidthCached = lw + rw;
  }
  int get minCharWidth {
    if (minCharWidthCached != null) return minCharWidthCached;
    return minCharWidthCached = l.minCharWidth + r.minCharWidth;
  }
  int get maxCharWidth {
    if (maxCharWidthIsCalculated) return maxCharWidthCached;
    maxCharWidthIsCalculated = true;
    int rw = r.maxCharWidth;
    if (rw == null) return null;
    int lw = l.maxCharWidth;
    if (lw == null) return null;
    return maxCharWidthCached = lw + rw;
  }
  bool get simple => l.simple && r.simple;
}

class EmptyAlternative extends Ast {
  EmptyAlternative(bool backwards) : super(backwards);
  String toString() => "";
  void gen(State s, String succ) {
    if (succ != null) {
      forward(s, "i32", name, succ);
    } else {
      _(s, 'define internal i32 @$name(%restate_t* %state, i8* %s) {');
      _(s, "  ret i32 0");  // Success, no offset.
      _(s, "}");
    }
  }
  int get minWidth => 0;
  int get maxWidth => 0;
  int get minCharWidth => 0;
  int get maxCharWidth => 0;
  bool get simple => true;
}

// A series of alternatives separated by '|'.
class Disjunction extends BinaryAst {
  Disjunction(Ast l, Ast r, bool backwards) : super(l, r, backwards);

  String toString() => "($l|$r)";
  void gen(State s, String succ) {
    _(s, 'define internal i32 @$name(%restate_t* %state, i8* %s) {');
    _(s, '  %left = call i32 @${l.name}(%restate_t* %state, i8* %s)');
    _(s, '  %comparison = ${check_for_failure(succ)} %left');
    _(s, '  br i1 %comparison, label %left_failed, label %left_succeded');
    _(s, 'left_succeded:');
    _(s, '  ret i32 %left');
    _(s, 'left_failed:');
    _(s, '  %right = call i32 @${r.name}(%restate_t* %state, i8* %s)');
    _(s, '  ret i32 %right');
    _(s, '}');
    l.gen(s, succ);
    r.gen(s, succ);
  }
  void genBacktrack(State s) {
    _(s, "define internal i8* @${name}_backtrack(%restate_t* %state, i8* %s) {");
    _(s, "  %prev = getelementptr i8, i8* %s, i64 ${(backwards ? 1 : -1) * l.minWidth}");
    _(s, "  ret i8* %prev");
    _(s, "}");
    l.genBacktrack(s);
    r.genBacktrack(s);
  }
  bool isAnchored() => l.isAnchored() && r.isAnchored();
  int get minWidth {
    if (minWidthCached != null) return minWidthCached;
    return minWidthCached = min(l.minWidth, r.minWidth);
  }
  int get maxWidth {
    if (maxWidthIsCalculated) return maxWidthCached;
    maxWidthIsCalculated = true;
    int rw = r.maxWidth;
    if (rw == null) return null;
    int lw = l.maxWidth;
    if (lw == null) return null;
    return maxWidthCached = max(lw, rw);
  }
  int get minCharWidth {
    if (minCharWidthCached != null) return minCharWidthCached;
    return minCharWidthCached = min(l.minCharWidth, r.minCharWidth);
  }
  int get maxCharWidth {
    if (maxCharWidthIsCalculated) return maxCharWidthCached;
    maxCharWidthIsCalculated = true;
    int rw = r.maxCharWidth;
    if (rw == null) return null;
    int lw = l.maxCharWidth;
    if (lw == null) return null;
    return maxCharWidthCached = max(lw, rw);
  }
  bool get simple {
    if (!l.simple || !r.simple) return false;
    // We could be more clever here if we can tell the ends of the two
    // different matches from each other when unwinding.  Even just detecting
    // that all branches have the same number of UTF-8 characters would be
    // better.
    return l.minWidth == r.minWidth && l.minWidth == l.maxWidth &&
        r.minWidth == r.maxWidth;
  }
}

abstract class UnaryAst extends Ast {
  UnaryAst(this.ast, bool backwards) : super(backwards);
  Ast ast;
  void dump() {
    super.dump();
    print('"$name" -> "${ast.name}";');
    ast.dump();
  }
  void alloc(State state) { ast.alloc(state); }
  int minWidthCached;
  int maxWidthCached;
  bool maxWidthIsCalculated = false;
  int minCharWidthCached;
  int maxCharWidthCached;
  bool maxCharWidthIsCalculated = false;
  int get minWidth {
    if (minWidthCached != null) return minWidthCached;
    return minWidthCached = ast.minWidth;
  }
  int get maxWidth {
    if (maxWidthIsCalculated) return maxWidthCached;
    maxWidthIsCalculated = true;
    return maxWidthCached = ast.maxWidth;
  }
  int get minCharWidth {
    if (minCharWidthCached != null) return minCharWidthCached;
    return minCharWidthCached = ast.minCharWidth;
  }
  int get maxCharWidth {
    if (maxCharWidthIsCalculated) return maxCharWidthCached;
    maxCharWidthIsCalculated = true;
    return maxCharWidthCached = ast.maxCharWidth;
  }
  void collect(State s, List<int> regs, bool goIntoLoops) {
    ast.collect(s, regs, goIntoLoops);
  }
}

class Lookahead extends UnaryAst {
  Lookahead(Ast ast, bool backwards, this.sense) : super(ast, backwards);
  bool sense;
  void gen(State s, String succ) {
    ast.gen(s, "match");
    _(s, "define internal i32 @$name(%restate_t* %state, i8* %s) {");
    _(s, "  %result = call i32 @${ast.name}(%restate_t* %state, i8* %s)");
    // The ast is never generated in recursion mode (always continuation mode),
    // so we check for zero meaning failure.
    _(s, "  %comparison = icmp ${sense ? "ne" : "eq"} i32 %result, 0");
    _(s, "  br i1 %comparison, label %ok, label %failed");
    _(s, "failed:");
    _(s, "  ret i32 ${failure_code(succ)}");
    _(s, "ok:");
    if (!sense) ClearCaptures(s);
    if (succ == null) {
      _(s, "ret i32 0");  // Success.
      _(s, "}");
      return;
    }
    _(s, "  %result2 = call i32 @$succ(%restate_t* %state, i8* %s)");
    if (sense) {
      _(s, "  %comparison2 = $compare_failure %result2");
      _(s, "  br i1 %comparison2, label %failed2, label %ok2");
      _(s, "failed2:");
      ClearCaptures(s);
      _(s, "  ret i32 ${failure_code(succ)}");
      _(s, "ok2:");
    }
    if (succ == null) {
      _(s, "  ret i32 0");  // Success.
    } else {
      _(s, "  ret i32 %result2");
    }
    _(s, "}");
  }
  void genBacktrack(State s) {
    _(s, "define internal i8* @${name}_backtrack(%restate_t* %state, i8* %s) {");
    _(s, "  ret i8* %s");
    _(s, "}");
  }
  void ClearCaptures(State s) {
    List<int> captures = [];
    ast.collect(s, captures, false);
    for (int reg in captures) {
      if (s.isCaptureRepresentation(reg)) {
        int r = s.getCapture(reg);
        for (int i = r; i < r + 2; i++) {
          _(s, "  %gep$i = getelementptr %restate_t, %restate_t* %state, i64 0, i32 1, i32 $i");
          _(s, "  store i8* null, i8** %gep$i");
        }
      }
      // No need to reset counters or zero width check registers since they are not visible to the API.
    }
  }
  String toString() => "(?${backwards ? '<' : ''}${sense ? '=' : '!'}$ast)";
  int get minWidth => 0;
  int get maxWidth => 0;
  int get minCharWidth => 0;
  int get maxCharWidth => 0;
  // You might think lookaheads are simple since they are constant width, but
  // positive lookaheads are not simple because you have to clear captures when
  // backtracking.
  bool get simple => !sense || ast.simple;
}

class Capturing extends UnaryAst {
  Capturing(Ast ast, bool backwards) : super(ast, backwards);
  int capture_register;
  // TODO: Set registers when capturing.
  void gen(State s, String succ) {
    int first = capture_register + (backwards ? 1 : 0);
    int second = capture_register + (backwards ? 0 : 1);
    _(s, "define internal i32 @$name(%restate_t* %state, i8* %s) {");
    _(s, "  %gep = getelementptr %restate_t, %restate_t* %state, i64 0, i32 1, i32 $first");
    _(s, "  store i8* %s, i8** %gep");
    _(s, "  %result = call i32 @${ast.name}(%restate_t* %state, i8* %s)");
    _(s, "  %comparison = $compare_failure %result");
    _(s, "  br i1 %comparison, label %failed, label %ok");
    _(s, "failed:");
    _(s, "  store i8* null, i8** %gep");
    _(s, "  ret i32 %result");
    _(s, "ok:");
    _(s, "  ret i32 %result");
    _(s, "}");
    _(s, "define internal i32 @${name}_close(%restate_t* %state, i8* %s) {");
    _(s, "  %gep = getelementptr %restate_t, %restate_t* %state, i64 0, i32 1, i32 $second");
    _(s, "  store i8* %s, i8** %gep");
    _(s, "  %result = call i32 @$succ(%restate_t* %state, i8* %s)");
    _(s, "  %comparison = icmp eq i32 0, %result");
    _(s, "  br i1 %comparison, label %failed, label %ok");
    _(s, "failed:");
    _(s, "  store i8* null, i8** %gep");
    _(s, "  ret i32 %result");
    _(s, "ok:");
    _(s, "  ret i32 %result");
    _(s, "}");
    ast.gen(s, "${name}_close");
  }
  void alloc(State state) {
    capture_register = state.captures;
    state.captures += 2;
    ast.alloc(state);
  }
  void collect(State s, List<int> regs, bool goIntoLoops) {
    regs.add(s.captureRepresentation(capture_register));
    ast.collect(s, regs, goIntoLoops);
  }
  String toString() => "(${backwards ? '←' : ''}$ast)";
  bool isAnchored() => ast.isAnchored();
  // We could make Capturing simple with some work, but for now it's not
  // simple, so (.)* will overflow your stack.
  bool get simple => false;
}

class Loop extends UnaryAst {
  Loop(Ast ast, this.min, this.max, this.nonGreedy, bool backwards) : super(ast, backwards);
  Loop.asterisk(Ast ast, this.nonGreedy, bool backwards) : super(ast, backwards);
  Loop.plus(Ast ast, this.nonGreedy, bool backwards) : super(ast, backwards) { min = 1; }
  int min = 0;
  int max = null;  // Nullable - null means no max.
  bool nonGreedy;
  bool get greedy => !nonGreedy;
  bool get counted => min != 0 || max != null;
  bool get zeroChecked => ast.minWidth == 0;
  int counter_register;
  int zero_check_register;
  String toString() {
    String n = greedy ? "" : "?";
    String b = backwards ? "←" : "";
    if (max == null) {
      if (min == 0) return "($ast)$b*$n";
      if (min == 1) return "($ast)$b+$n";
      return "($ast)$b{$min,}$n";
    }
    if (min == max) return "($ast)$b{$min}$n";
    return "($ast)$b{$min,$max}$n";
  }
  // For greedy loops, we first try to match the body of the loop, and only if
  // that fails, we try to match the successor.  For non-greedy loops we use
  // the opposite order.  When matching the body, the loop itself is the
  // successor - despite the name "Loop", we are implementing this using
  // recursion.
  void gen(State s, String succ) {
    if (max == 0) {
      forward(s, "i32", name, succ);
      return;
    }
    if (greedy && ast.simple) {
      simpleGen(s, succ);
      return;
    }
    List<int> savedCounters;
    String first_call = greedy ? ast.name : succ;
    String second_call = greedy ? succ : ast.name;
    _(s, "define internal i32 @$name(%restate_t* %state, i8* %s) {");
    genPreCounter(s);
    if (greedy) savedCounters = saveCounters(s);
    _(s, "  %result = call i32 @$first_call(%restate_t* %state, i8* %s)");
    genPreCounterReturn(s);
    _(s, "  %comparison = $compare_failure %result");
    _(s, "  br i1 %comparison, label %failed, label %ok");
    _(s, "failed:");
    if (greedy) restoreCounters(s, savedCounters);
    _(s, "  br label %failed_post_restore_counters");
    _(s, "failed_post_restore_counters:");
    genPostCounter(s);
    if (!greedy) savedCounters = saveCounters(s);
    _(s, "  %succ = call i32 @$second_call(%restate_t* %state, i8* %s)");
    genPostCounterReturn(s, savedCounters);
    _(s, "  ret i32 %succ");
    _(s, "ok:");
    _(s, "  ret i32 1");
    _(s, "}");
    ast.gen(s, name);
  }
  // The counters and captures for inner loops have to be reset to 0 when we
  // start this outer loop, but we save the old values in case we backtrack.
  List<int> saveCounters(State s) {
    List<int> regs = [];
    ast.collect(s, regs, false);
    for (int reg in regs) {
      if (s.isCaptureRepresentation(reg)) {
        int capture = s.getCapture(reg);
        for (int i = capture; i < capture + 2; i++) {
          _(s, "  %gep_capture$i = getelementptr %restate_t, %restate_t* %state, i64 0, i32 1, i32 $i");
          _(s, "  %cap$i = load i8*, i8** %gep_capture$i");
          _(s, "  store i8* null, i8** %gep_capture$i");
        }
      } else if (s.isCounterRepresentation(reg)) {
        int count = s.getCounter(reg);
        _(s, "  %gep_count$count = getelementptr %restate_t, %restate_t* %state, i64 0, i32 2, i32 $count");
        _(s, "  %count$count = load i32, i32* %gep_count$count");
        _(s, "  store i32 0, i32* %gep_count$count");
      } else {
        int z = s.getZeroCheck(reg);
        _(s, "  %gep_zero_check$z = getelementptr %restate_t, %restate_t* %state, i64 0, i32 3, i32 $z");
        _(s, "  %zero_check$z = load i8*, i8** %gep_zero_check$z");
        _(s, "  store i8* null, i8** %gep_zero_check$z");
      }
    }
    return regs;
  }
  void restoreCounters(State s, List<int> regs) {
    for (int reg in regs) {
      if (s.isCaptureRepresentation(reg)) {
        int r = s.getCapture(reg);
        for (int i = r; i < r + 2; i++) {
          _(s, "  store i8* %cap$i, i8** %gep_capture$i");
        }
      } else if (s.isCounterRepresentation(reg)) {
        int count = s.getCounter(reg);
        _(s, "  store i32 %count$count, i32* %gep_count$count");
      } else {
        int z = s.getZeroCheck(reg);
        _(s, "  store i8* %zero_check$z, i8** %gep_zero_check$z");
      }
    }
  }
  // If this loop is counted then increment the counter and check that we have
  // not exceeded the max number of iterations.
  void genPreCounter(State s) {
    if (counted) {
      _(s, "  %gep = getelementptr %restate_t, %restate_t* %state, i64 0, i32 2, i32 ${counter_register}");
      _(s, "  %counter = load i32, i32* %gep");
    }
    if (zeroChecked) {
      int z = zero_check_register;
      _(s, "  %gep_zero_check = getelementptr %restate_t, %restate_t* %state, i64 0, i32 3, i32 $z");
      _(s, "  %zero_check = load i8*, i8** %gep_zero_check");
      if (min != 0) {
        _(s, "  %zcounter_compare = icmp ult i32 %counter, $min");
        _(s, "  br i1 %zcounter_compare, label %dont_check_zero, label %check_zero");
        _(s, "check_zero:");
      }
      _(s, "  %zcomparison = icmp eq i8* null, %zero_check");
      _(s, "  br i1 %zcomparison, label %store_z, label %check_against_s");
      _(s, "check_against_s:");
      _(s, "  %zcomparison2 = icmp eq i8* %s, %zero_check");
      _(s, "  br i1 %zcomparison2, label %zero_fail, label %store_z");
      _(s, "zero_fail:");
      _(s, "  ret i32 0");
      _(s, "store_z:");
      _(s, "  store i8* %s, i8** %gep_zero_check");
      _(s, "  br label %dont_check_zero");
      _(s, "dont_check_zero:");
    }
    if (max != null && greedy) {
      _(s, "  %maxcomp = icmp eq i32 %counter, $max");
      _(s, "  br i1 %maxcomp, label %failed_post_restore_counters, label %counter_low_enough");
      _(s, "counter_low_enough:");
    } else if (min != 0 && !greedy) {
      _(s, "  %mincomp = icmp ult i32 %counter, $min");
      _(s, "  br i1 %mincomp, label %failed_post_restore_counters, label %counter_big_enough");
      _(s, "counter_big_enough:");
    }
    if (counted && greedy) {
      _(s, "  %incremented = add i32 %counter, 1");
      _(s, "  store i32 %incremented, i32* %gep");
    }
  }
  void genPreCounterReturn(State s) {
    if (counted && greedy) _(s, "  store i32 %counter, i32* %gep");
    if (greedy && zeroChecked) _(s, "  store i8* %zero_check, i8** %gep_zero_check");
  }
  // If this loop is counted then restore the counter (decrementing it) and
  // check that we have hit at least the min number of iterations.
  void genPostCounter(State s) {
    if (min != 0 && greedy) {
      _(s, "  %mincomp = icmp ult i32 %counter, $min");
      _(s, "  br i1 %mincomp, label %counter_too_low, label %counter_big_enough");
      _(s, "counter_too_low:");
      _(s, "  ret i32 0;");
      _(s, "counter_big_enough:");
    } else if (max != null && !greedy) {
      _(s, "  %maxcomp = icmp eq i32 %counter, $max");
      _(s, "  br i1 %maxcomp, label %counter_too_high, label %counter_low_enough");
      _(s, "counter_too_high:");
      _(s, "  ret i32 0;");
      _(s, "counter_low_enough:");
    }
    if (counted && !greedy) {
      _(s, "  %incremented = add i32 %counter, 1");
      _(s, "  store i32 %incremented, i32* %gep");
    }
  }
  void genPostCounterReturn(State s, List<int> savedCounters) {
    if (!greedy && savedCounters.length != 0) {
      _(s, "  %comparison2 = $compare_failure %succ");
      _(s, "  br i1 %comparison2, label %failed2, label %ok2");
      _(s, "failed2:");
      restoreCounters(s, savedCounters);
      _(s, "  br label %ok2");
      _(s, "ok2:");
    }
    if (!greedy && zeroChecked) _(s, "  store i8* %zero_check, i8** %gep_zero_check");
    if (counted && !greedy) _(s, "  store i32 %counter, i32* %gep");
  }
  // Generate a loop by calling the body and expecting it to return a number of
  // characters matched.  This avoids stack overflow on some greedy loops.
  void simpleGen(State s, String succ) {
    _(s, "define internal i32 @$name(%restate_t* %state, i8* %s) {");
    _(s, "  %posn = alloca i8*");
    if (counted) _(s, "  %loop = alloca i32");
    _(s, "  store i8* %s, i8** %posn");
    if (counted) _(s, "  store i32 0, i32* %loop");
    _(s, "  br label %loop_top");
    _(s, "loop_top:");
    _(s, "  %pos_loaded0 = load i8*, i8** %posn");
    _(s, "  %body = call i32 @${ast.name}(%restate_t* %state, i8* %pos_loaded0)");
    _(s, "  %comparison = ${check_for_failure(null)} %body");
    _(s, "  br i1 %comparison, label %body_failure, label %body_success");
    _(s, "body_failure:");
    if (min != 0) {
      _(s, "  %loop_loaded = load i32, i32* %loop");
      _(s, "  %min_comparison = icmp ult i32 %loop_loaded, $min");
      _(s, "  br i1 %min_comparison, label %total_failure, label %min_check_success");
      _(s, "total_failure:");
      _(s, "  ret i32 0");
      _(s, "min_check_success:");
    }
    _(s, "  br label %try_successor");
    _(s, "try_successor:");
    _(s, "  %pos_loaded = load i8*, i8** %posn");
    _(s, "  %succ_return = call i32 @${succ}(%restate_t* %state, i8* %pos_loaded)");
    _(s, "  %succ_comparison = $compare_failure %succ_return");
    _(s, "  br i1 %succ_comparison, label %succ_failure, label %succ_success");
    _(s, "succ_success:");
    _(s, "  ret i32 1");
    _(s, "succ_failure:");
    if (counted) {
      // Successor failed, time to backtrack, but first check if we are totally
      // backtracked.
      _(s, "  %loop_loaded2 = load i32, i32* %loop");
      _(s, "  %min_comparison2 = icmp eq i32 %loop_loaded2, $min");
    } else {
      // If there's no counter, then check whether we are back at the starting
      // point.
      _(s, "  %pos_loaded2 = load i8*, i8** %posn");
      _(s, "  %min_comparison2 = icmp eq i8* %pos_loaded2, %s");
    }
    _(s, "  br i1 %min_comparison2, label %total_failure2, label %min_check_success2");
    _(s, "total_failure2:");
    _(s, "  ret i32 0");
    _(s, "min_check_success2:");
    _(s, "  %pos_loaded3 = load i8*, i8** %posn");
    _(s, "  %pos_loaded4 = call i8* @${ast.name}_backtrack(%restate_t* %state, i8* %pos_loaded3)");
    _(s, "  store i8* %pos_loaded4, i8** %posn");
    if (counted) {
      _(s, "  %loop_loaded3 = load i32, i32* %loop");
      _(s, "  %loop_loaded4 = sub i32 %loop_loaded3, 1");
      _(s, "  store i32 %loop_loaded4, i32* %loop");
    }
    _(s, "  br label %body_failure");

    // On the other hand if the body succeeded.
    _(s, "body_success:");
    if (counted) {
      _(s, "  %loop_loaded5 = load i32, i32* %loop");
      _(s, "  %loop_loaded6 = add i32 %loop_loaded5, 1");
      _(s, "  store i32 %loop_loaded6, i32* %loop");
    }
    _(s, "  %pos_loaded5 = load i8*, i8** %posn");
    // Equivalently add %body (not equivalent if the body can one day be non-constant-width).
    _(s, "  %pos_loaded6 = getelementptr i8, i8* %pos_loaded5, i32 %body");
    _(s, "  store i8* %pos_loaded6, i8** %posn");
    if (max != null) {
      _(s, "  %max_comparison = icmp eq i32 %loop_loaded6, $max");
      _(s, "  br i1 %max_comparison, label %try_successor, label %loop_top");
    } else {
      _(s, "  br label %loop_top");
    }
    _(s, "}");
    // Generate body in non-continuation (call-return) mode.
    ast.gen(s, null);
    ast.genBacktrack(s);
  }
  void alloc(State state) {
    if (counted) counter_register = state.counters++;
    if (ast.minWidth == 0) zero_check_register = state.zeroChecks++;
    ast.alloc(state);
  }
  void collect(State s, List<int> regs, bool goIntoLoops) {
    if (counted) regs.add(s.counterRepresentation(counter_register));
    if (zero_check_register != null) regs.add(s.zeroCheckRepresentation(zero_check_register));
    if (goIntoLoops) ast.collect(s, regs, goIntoLoops);
  }
  bool isAnchored() => min > 0 && ast.isAnchored();
  int get minWidth {
    if (min == 0) return 0;
    return min * super.minWidth;
  }
  int get maxWidth {
    if (max == null) {
      if (super.maxWidth == 0) return 0;
      return null;
    }
    int w = super.maxWidth;
    if (w == null) return null;
    return max * w;
  }
  int get minCharWidth {
    if (min == 0) return 0;
    return min * super.minCharWidth;
  }
  int get maxCharWidth {
    if (max == null) {
      if (super.maxCharWidth == 0) return 0;
      return null;
    }
    int w = super.maxCharWidth;
    if (w == null) return null;
    return max * w;
  }
}

class ParseError {
  ParseError(this.string, this.pos);
  String string;
  int pos;
}

class Parser {
  Parser(this.src, this.mode) {
    allowLenient = (mode == "js" || mode == "perl");
    allowLookbehind = (mode != "js");
  }
  String src;
  String mode;
  bool allowLenient;
  bool allowLookbehind;
  int pos = 0;
  String current;
  bool backwards = false;
  int capturingBracketCount = 0;

  void die(String s) {
    throw new ParseError(s, pos);
  }

  void checkForNull() {
    if (currentCodePoint == 0) die("Can't allow null characters in a Grut regexp");
  }

  Ast parse() {
    if (mode == 'js') jsCountCaptures();
    getToken();
    Ast ast;
    try {
      ast = parseDisjunction();
      expect("");
    } on ParseError catch (error) {
      stderr.writeln("Grut error: ${error.string} at ${error.pos}");
      stderr.writeln(src);
      stderr.writeln("^".padLeft(error.pos + 1, " "));
      return null;
    }
    ast = new Capturing(ast, false);  // Implicit 0th capture is whole match.
    if (!ast.isAnchored()) {
      // For non-sticky regexps (which is the only thing we support) we prepend
      // a non-greedy loop).
      ast = new Alternative(new Loop.asterisk(new Utf8Dot(false), true, backwards), ast, false);
    }
    return ast;
  }

  Ast parseAtom() {
    if (accept("(")) {
      bool capturing = true;
      bool lookaround = false;
      bool lookaroundSense;
      bool lookahead = true;
      if (accept("?")) {
        if (mode == 'perl' && accept("#")) {
          int saved_pos = pos;
          while (!accept(")")) {
            if (current == "") {
              pos = saved_pos - 1;
              die("Missing end of (?#...) comment");
            }
            accept(current);
          }
          accept(")");
          return new EmptyAlternative(backwards);
        }
        if (accept("<")) {
          if (!allowLookbehind) die("Lookbehind not available in $mode mode");
          lookahead = false;
        }
        if (accept("=")) {
          lookaround = true;
          lookaroundSense = true;
        } else if (accept("!")) {
          lookaround = true;
          lookaroundSense = false;
        } else {
          expect(":");
        }
        if (!lookahead && !lookaround) die("(?< must be followed by = or !");
        capturing = false;
      }
      Ast ast;
      if (!capturing) {
        bool oldDirection = backwards;
        if (lookaround) backwards = !lookahead;
        ast = parseDisjunction();
        backwards = oldDirection;
      } else {
        ast = parseDisjunction();
      }
      if (capturing) ast = new Capturing(ast, backwards);
      if (lookaround) ast = new Lookahead(ast, backwards, lookaroundSense);
      expect(")");
      return ast;
    }
    if (current == "|" || current == ")" || current == "") return null;
    if (accept(".")) return new Utf8Dot(backwards);
    if (accept("\\")) return parseEscape();
    if (accept("[")) return parseCharClass();
    if (accept("*") || accept("?") || accept("+"))
      die("Unexpected quantifier");
    if ((current == "{" || current == "}") && !allowLenient)
      die("Literal { and } must be escaped in $mode mode");
    // TODO: Should we (unlike Dart and JS) disallow a bare ']' here?
    checkForNull();
    Ast ast = new Ast.literalCode(currentCodePoint, backwards);
    accept(current);
    return ast;
  }

  Ast parseCharClass() {
    CharacterClass c = new CharacterClass(backwards);
    bool negated = accept("^");
    while (!accept("]")) {
      int from, to;
      if (accept(r"\")) {
        CharacterClass clarse = acceptClassLetter();
        if (clarse != null) {
          c.mergeIn(clarse);
          continue;
        }
        int ascii = acceptAsciiEscape();
        if (ascii != null) {
          from = ascii;
        } else {
          checkEscape();
          checkForNull();
          from = currentCodePoint;
          accept(current);
        }
      } else if (accept("")) {
        die("Unexpected end of regexp");
      } else {
        checkForNull();
        if (current == "-" && !allowLenient) die( "Literal dash must be escaped in character classes in $mode mode");
        from = currentCodePoint;
        accept(current);
      }
      if (!accept("-")) {
        c.addNumeric(from, from);
        continue;
      }
      if (accept(r"\")) {
        CharacterClass clarse = acceptClassLetter();
        if (clarse != null) {
          if (!allowLenient) die("Character class as end of a range");
          c.mergeIn(clarse);
          c.add("-", "-");
          c.addNumeric(from, from);
          continue;
        }
        int ascii = acceptAsciiEscape();
        if (ascii != null) {
          to = ascii;
        } else {
          checkEscape();
          checkForNull();
          to = currentCodePoint;
          accept(current);
        }
      } else if (accept("")) {
        die("Unexpected end of regexp");
      } else {
        checkForNull();
        to = currentCodePoint;
        accept(current);
      }
      if (from > to) die("Invalid range");
      c.addNumeric(from, to);
    }
    c.sortMerge();
    if (negated) c.negate();
    return c;
  }

  int acceptAsciiEscape() {
    if (accept("n")) return "\n".codeUnitAt(0);
    if (accept("f")) return "\f".codeUnitAt(0);
    if (accept("v")) return "\v".codeUnitAt(0);
    if (accept("t")) return "\t".codeUnitAt(0);
    if (accept(r"\")) return r"\".codeUnitAt(0);
    if (accept("r")) return "\r".codeUnitAt(0);

    int zero = '0'.codeUnitAt(0);
    int a = 'a'.codeUnitAt(0);
    int A = 'A'.codeUnitAt(0);

    if (mode == 'js' && current == "c") {
      // Remember that pos is 1 ahead of current.
      // We have to peek ahead here because in js mode \cz means control-Z, but
      // \c0 means '\c0', including a literal backslash!
      if (pos + 1 >= src.length) return r'\'.codeUnitAt(0);
      int code = src.codeUnitAt(pos);
      if (code >= a && code <= a + 25) {
        accept("c");
        accept(current);
        return code - a - 1;
      } else if (code >= A && code <= A + 25) {
        accept("c");
        accept(current);
        return code - A - 1;
      } else {
        return r'\'.codeUnitAt(0);
      }
    }
    int digits = (current == "u") ? 4 : 2;
    if (accept("x") || accept("u")) {
      bool find_curly = accept("{");
      if (find_curly) digits = 6;
      int hex = 0;
      for (int digit = 0; digit < digits; digit++) {
        int code = currentCodePoint;
        if (code >= zero && code <= zero + 9)
          hex = hex * 16 + code - zero;
        else if (code >= a && code <= a + 5)
          hex = hex * 16 + 10 + code - a;
        else if (code >= A && code <= A + 5)
          hex = hex * 16 + 10 + code - A;
        else if (find_curly && accept("}"))
          break;
        else
          die("Invalid $digits-digit hex escape");
        accept(current);
      }
      if (hex == 0) die("Can't allow null characters in a Grut regexp");
      if (hex > 0x10ffff) die("Unicode escape out of range");
      return hex;
    }

    return null;
  }

  // Only returns non-null if the entire decimal number that starts here makes
  // up a valid backref number.  Doesn't consume anything unless advance is
  // true.  May return a throwaway Ast depending on context.
  Ast acceptBackreference(bool advance) {
    if (!isDecimal(current)) return null;
    if (current == "0") return null;

    int num = 0;
    int zero = '0'.codeUnitAt(0);
    // Pos is 1 ahead, so start at -1.
    int p = pos;
    for (int i = -1; p + i < src.length; i++) {
      String c = src[p + i];
      if (!isDecimal(c)) return new Backreference(num, backwards, mode == 'js');
      num = num * 10 + c.codeUnitAt(0) - zero;
      if (num > capturingBracketCount && mode == "js") return null;
      if (advance) accept(current);
    }
    return new Backreference(num, backwards, mode == 'js');
  }

  Ast acceptNumericEscape() {
    if (!isDecimal(current)) return null;
    if (mode == 'js') {
      // JS mode has both octal escapes and backreferences, and they have the
      // same syntax. The way to do it is to peek forwards at all the decimal
      // digits and determine if they all together make up a valid
      // backreference (relative to the number of captures).  If so, it's a
      // backreference.  Otherwise it might be an octal escape, possibly
      // followed by literal digits.
      if (acceptBackreference(false) != null) return acceptBackreference(true);
      if (isOctal(current)) return acceptOctalEscape();
      return null;
    } else {
      // Other regexp flavours don't have octal escapes, so it must be a
      // backreference.
      Ast ref = acceptBackreference(false);  // Peek.
      if (ref == null) die("Backref number out of range 1-$capturingBracketCount");
      acceptBackreference(true);  // Consume input.
      return ref;
    }
  }

  Ast acceptOctalEscape() {
    if (!isOctal(current)) return null;
    int zero = '0'.codeUnitAt(0);
    int octal = currentCodePoint - zero;
    accept(current);

    bool three_digits_possible = octal <= 3;  // Only allow 1 to 0377.
    if (!isOctal(current)) return escapeGate(octal);
    octal = octal * 8 + currentCodePoint - zero;
    accept(current);

    if (!three_digits_possible || !isOctal(current)) return escapeGate(octal);
    octal = octal * 8 + currentCodePoint - zero;
    accept(current);
    return escapeGate(octal);
  }

  Ast escapeGate(int code) {
    if (code == 0) die("Can't allow null characters in a Grut regexp");
    return new Ast.literalCode(code, backwards);
  }

  bool isDecimal(String c) {
    int digit = c.codeUnitAt(0) - '0'.codeUnitAt(0);
    return digit >= 0 && digit <= 9;
  }

  bool isOctal(String c) {
    int digit = c.codeUnitAt(0) - '0'.codeUnitAt(0);
    return digit >= 0 && digit <= 7;
  }

  Ast acceptBoundary() {
    String b = current;
    if (accept("b") || accept("B")) {
      Ast word_left = new Lookahead(new CharacterClass.word(true), true, true);
      Ast not_word_right = new Lookahead(new CharacterClass.word(false), false, false);
      Ast not_word_left = new Lookahead(new CharacterClass.word(true), true, false);
      Ast word_right = new Lookahead(new CharacterClass.word(false), false, true);
      if (b == "b") {
        Ast start = new Alternative(not_word_left, word_right, false);
        Ast end = new Alternative(word_left, not_word_right, false);
        return new Disjunction(start, end, backwards);
      } else {
        Ast in_word = new Alternative(word_left, word_right, false);
        Ast not_in_word = new Alternative(not_word_left, not_word_right, false);
        return new Disjunction(in_word, not_in_word, backwards);
      }
    }
    return null;
  }

  Ast parseEscape() {
    int ascii = acceptAsciiEscape();
    if (ascii != null) return new Ast.literalCode(ascii, backwards);
    Ast boundary = acceptBoundary();
    if (boundary != null) return boundary;
    CharacterClass clarse = acceptClassLetter();
    if (clarse != null) return clarse;
    Ast esc = acceptNumericEscape();
    if (esc != null) return esc;
    checkEscape();
    checkForNull();
    Ast ast = new Ast.literalCode(currentCodePoint, backwards);
    accept(current);
    return ast;
  }

  void checkEscape() {
    if (accept("")) die("Unexpected end of regexp");
    if (mode != "js") {
      if (currentCodePoint >= 'a'.codeUnitAt(0) &&
          currentCodePoint <= 'z'.codeUnitAt(0)) die("Unsupported escape");
      if (currentCodePoint >= 'A'.codeUnitAt(0) &&
          currentCodePoint <= 'Z'.codeUnitAt(0)) die("Unsupported escape");
      if (currentCodePoint >= '0'.codeUnitAt(0) &&
          currentCodePoint <= '9'.codeUnitAt(0)) die("Unsupported escape");
    }
  }

  Ast parseTerm() {
    if (accept("^")) return new Start(backwards);
    if (accept("\$")) return new End(backwards);
    Ast ast = parseAtom();
    if (ast == null) return null;
    if (accept("?")) {
      Ast empty = new EmptyAlternative(backwards);
      if (accept("?"))
        return new Disjunction(empty, ast, backwards);  // Non-greedy "?".
      return new Disjunction(ast, empty, backwards);  // Greedy "?".
    }
    if (accept("*")) return new Loop.asterisk(ast, accept("?"), backwards);
    if (accept("+")) return new Loop.plus(ast, accept("?"), backwards);
    if (accept("{")) {
      // .{2}   - exactly two matches.
      // .{2,}  - at least two matches.
      // .{2,3} - Between two and three matches.
      int min = expectNumber();
      int max = accept(",") ? acceptNumber() : min;
      if (max != null && max < min) die("min must be <= max");
      expect("}");
      return new Loop(ast, min, max, accept("?"), backwards);
    }
    return ast;
  }

  Ast parseAlternative() {
    Ast ast = parseTerm();
    if (ast == null) return new EmptyAlternative(backwards);
    while (true) {
      Ast next = parseTerm();
      if (next == null) return ast;
      if (backwards)
        ast = new Alternative(next, ast, backwards);
      else
        ast = new Alternative(ast, next, backwards);
    }
  }

  Ast parseDisjunction() {
    Ast ast = parseAlternative();
    while (accept("|")) {
      ast = new Disjunction(ast, parseAlternative(), backwards);
    }
    return ast;
  }

  void getToken() {
    if (pos == src.length) {
      current = "";
    } else {
      current = src[pos++];
      int code = current.codeUnitAt(0);
      if (code >= 0xd800 && code < 0xdc00 && pos < src.length) {
        int code2 = src.codeUnitAt(pos);
        if (code2 >= 0xdc00 && code2 < 0xe000) {
          current += src[pos++];
        }
      }
    }
  }

  int get currentCodePoint {
    if (current.length == 1) return current.codeUnitAt(0);
    if (current.length == 0) throw "Bug in parser: Hit end of input";
    // UTF-16 surrogate pair.
    int res = 0x10000 + ((current.codeUnitAt(0) & 0x3ff) << 10) + (current.codeUnitAt(1) & 0x3ff);
    return res;
  }

  void expect(String token) {
    if (token != current) die("Expected '$token', found '$current'");
    getToken();
  }

  bool accept(String token) {
    if (token != current) return false;
    getToken();
    return true;
  }

  int expectNumber() {
    int result = acceptNumber();
    if (result == null) die("Expected number, found '$current'");
    return result;
  }

  int acceptNumber() {
    int result = null;
    int ascii_zero = '0'.codeUnitAt(0);
    while (true) {
      if (current == "") return result;
      int code = currentCodePoint - ascii_zero;
      if (code < 0 || code > 9) return result;
      result = result == null ? code : result * 10 + code;
      getToken();
    }
  }

  CharacterClass acceptClassLetter() {
    if (accept("d")) return new CharacterClass.digit(backwards);
    if (accept("s")) return new CharacterClass.whiteSpace(backwards);
    if (accept("w")) return new CharacterClass.word(backwards);
    if (accept("D")) return new CharacterClass.notDigit(backwards);
    if (accept("S")) return new CharacterClass.notWhiteSpace(backwards);
    if (accept("W")) return new CharacterClass.notWord(backwards);
    return null;
  }

  // For JS mode we need to count the captures first because you can't parse
  // backrefs without that info.
  void jsCountCaptures() {
    bool in_class = false;
    for (int i = 0; i < src.length - 1; i++) {
      // JS does not have inlined comments, so it's fairly simple to count
      // capturing brackets.  All non-capturing brackets look like (?...).
      int code = src.codeUnitAt(i);
      if (code == r'\'.codeUnitAt(0)) {
        i++;
        continue;
      } else if (!in_class && code == '('.codeUnitAt(0)) {
        // Check for non-capturing.
        if (src.codeUnitAt(i + 1) == '?'.codeUnitAt(0)) continue;
        capturingBracketCount++;
      } else if (!in_class && code == '['.codeUnitAt(0)) {
        in_class = true;
      } else if (in_class && code == ']'.codeUnitAt(0)) {
        in_class = false;
      }
    }
  }
}

void defineMatch(IOSink out) {
  // The successor of the regexp, called if the match succeeds.  It just
  // returns '1' for success.
  out.writeln("define internal i32 @match(%restate_t* %state, i8* %s) {");
  out.writeln("  ret i32 1");
  out.writeln("}");
  out.writeln("declare i32 @checkBackref(i8*, i8*, i8*, i8*, i32*, i32, i32)");
  out.writeln("declare i32 @checkMultiByteBackwards(i8*, i8*)");
  out.writeln("declare i32 @check3Or4Utf8(i8*)");
}

void defineTopLevel(State state, String symbol, String name) {
  IOSink out = state.out;
  out.writeln("define external i32 @$symbol(%restate_t* %state, i8* %s) {");
  out.writeln("  %comparison = icmp eq i8* null, %s");
  out.writeln("  br i1 %comparison, label %getmetadata, label %matchstring");
  out.writeln("getmetadata:");
  out.writeln("  ret i32 ${state.captures}");
  out.writeln("matchstring:");
  out.writeln("  %start_gep = getelementptr %restate_t, %restate_t* %state, i64 0, i32 0");
  out.writeln("  store i8* %s, i8** %start_gep");
  for (int i = 0; i < state.captures; i++) {
    out.writeln("  %capture_gep$i = getelementptr %restate_t, %restate_t* %state, i64 0, i32 1, i32 $i");
    out.writeln("  store i8* null, i8** %capture_gep$i");
  }
  for (int i = 0; i < state.counters; i++) {
    out.writeln("  %counter_gep$i = getelementptr %restate_t, %restate_t* %state, i64 0, i32 2, i32 $i");
    out.writeln("  store i32 0, i32* %counter_gep$i");
  }
  for (int i = 0; i < state.zeroChecks; i++) {
    out.writeln("  %zero_check_gep$i = getelementptr %restate_t, %restate_t* %state, i64 0, i32 3, i32 $i");
    out.writeln("  store i8* null, i8** %zero_check_gep$i");
  }
  out.writeln("  %result = call i32 @$name(%restate_t* %state, i8* %s)");
  out.writeln("  ret i32 %result");
  out.writeln("}");
}

void usage() {
  stderr.writeln("Usage: grut");
  stderr.writeln("  [-e <regexp>]");
  stderr.writeln("  [-f <regexp_file>]  (read regexp source from file, strip final newline)");
  stderr.writeln("  [-d]                (produce graphviz file)");
  stderr.writeln("  [-l]                (produce LLVM file)");
  stderr.writeln("  [-o filename]       (write to file, default stdout)");
  stderr.writeln("  [-s <symbol>]       (default 'grut')");
  stderr.writeln("  [-m <mode>]         (default 'grut', can also be 'js' or 'perl'");
}

void main(List<String> args) {
  String source;
  String topSymbol = "grut";
  String filename;
  bool dotFile = false;
  bool llFile = false;
  String mode = "grut";
  for (int i = 0; i < args.length; i++) {
    switch (args[i]) {
      case "-e":
        source = args[++i];
        break;
      case "-f":
        source = new File(args[++i]).readAsStringSync();
        if (source.endsWith("\n")) source = source.substring(0, source.length - 1);
        break;
      case "-o":
        filename = args[++i];
        break;
      case "-d":
        dotFile = true;
        break;
      case "-l":
        llFile = true;
        break;
      case "-s":
        topSymbol = args[++i];
        break;
      case "-m":
        mode = args[++i];
        if (mode != "js" && mode != "perl") {
          stderr.writeln("Modes available: js, perl");
          exitCode = 1;
          return;
        }
        break;
      default:
        usage();
        exitCode = 1;
        return;
    }
  }
  if (!dotFile && !llFile) {
    stderr.writeln("Specify either -d or -l on the command line");
    usage();
    exitCode = 1;
    return;
  }
  if (dotFile && llFile && filename == null) {
    stderr.writeln("You can't specify both .ll and .dot files to be output to stdout");
    usage();
    exitCode = 1;
    return;
  }
  if (source == null) {
    stderr.writeln("No regexp specified");
    usage();
    exitCode = 1;
    return;
  }

  if (dotFile) {
    Parser parser = new Parser(source, mode);
    Ast ast = parser.parse();
    if (ast == null) return;
    print("Digraph G {");
    ast.dump();
    print("}");
  }
  if (llFile) {
    if (filename != null) {
      llvmCodeGen(new File(filename).openWrite(), source, topSymbol, mode);
    } else {
      llvmCodeGen(stdout, source, topSymbol, mode);
    }
  }
  return;
}

void llvmCodeGen(IOSink out, String source, String topSymbol, String mode) {
  Parser parser = new Parser(source, mode);
  Ast ast = parser.parse();
  if (ast == null) {
    exitCode = 1;
    return;
  }
  State state = new State(out);
  defineMatch(out);
  ast.alloc(state);
  out.writeln("%restate_t = type { i8*, [${state.captures} x i8*], [${state.counters} x i32], [${state.zeroChecks} x i8*] }");
  ast.gen(state, "match");
  defineTopLevel(state, topSymbol, ast.name);
  out.close();
}
