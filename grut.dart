class State {
  int captures = 0;
  int counters = 0;
}

abstract class Ast {
  static int ctr = 0;
  String name = "f${ctr++}";

  // Prints the dot-file (graphviz) output for each AST node.
  void dump() {
    print('"$name" [label="$this"];');
  }
  // Prints the .ll (LLVM ASCII bitcode) code for this node.  Each regexp AST
  // node is code-generated by creating one function, though LLVM will later
  // inline a lot of the trivial ones.
  void gen(State state, String successor);
  // For each AST node, determines how many registers (slots of storage in the
  // state) we are going to need when code generating.
  void alloc(State state) {}
  // Utility function used by gen.  Merely calls a different function and
  // returns whatever that function returns.
  void forward(String to) {
    print("define internal i32 @$name(%restate_t* %state, i8* %s) {");
    print("  %result = call i32 @$to(%restate_t* %state, i8* %s)");
    print("  ret i32 %result");
    print("}");
  }
}

abstract class BinaryAst extends Ast {
  BinaryAst(this.l, this.r);
  Ast l, r;

  void dump() {
    print('"$name" [label="$this"];');
    print('"$name" -> "${l.name}";');
    print('"$name" -> "${r.name}";');
    l.dump();
    r.dump();
  }
  void alloc(State state) {
    l.alloc(state);
    r.alloc(state);
  }
}

class Dot extends Single {
  String get condition => "ne";
  int get code => 0;
  String toString() => ".";
}

class Literal extends Single {
  Literal(this.char);
  String char;

  String get condition => "eq";
  int get code => char.codeUnitAt(0);
  String toString() => char;
}

// Single char superclass.
abstract class Single extends Ast {
  String get condition;
  int get code;

  void gen(State state, String successor) {
    print("define internal i32 @$name(%restate_t* %state, i8* %s) {");
    // char c = *s
    print("  %c = load i8, i8* %s, align 1");
    // bool comparison = c == ascii_code_of_literal
    print("  %comparison = icmp $condition i8 %c, $code");
    // if comparison goto matched else goto got_result;
    print("  br i1 %comparison, label %matched, label %got_result");
    print("matched:");
    // char* next = s + 1;
    print("  %next = getelementptr i8, i8* %s, i64 1");
    // int succ_result = f42(next);
    print("  %succ_result = call i32 @$successor(%restate_t* %state, i8* %next)");
    // goto got_result;
    print("  br label %got_result");
    print("got_result:");
    // int result = phi(succ_result, 0);
    print("  %result = phi i32 [ %succ_result, %matched ], [ 0, %0 ]");
    // return result
    print("  ret i32 %result");
    print("}");
  }
}

// A series of terms matched one after the other.
class Alternative extends BinaryAst{
  Alternative(Ast l, Ast r) : super(l, r);

  String toString() => "($l$r)";
  void gen(State state, String succ) {
    forward(l.name);
    l.gen(state, r.name);
    r.gen(state, succ);
  }
}

class EmptyAlternative extends Ast {
  String toString() => "";
  void gen(State state, String succ) {
    forward(succ);
  }
}

// A series of alternatives separated by '|'.
class Disjunction extends BinaryAst{
  Disjunction(Ast l, Ast r) : super(l, r);

  String toString() => "($l|$r)";
  void gen(State state, String succ) {
    print('define internal i32 @$name(%restate_t* %state, i8* %s) {');
    print('  %left = call i32 @${l.name}(%restate_t* %state, i8* %s)');
    print('  %comparison = icmp eq i32 %left, 0');
    print('  br i1 %comparison, label %left_failed, label %got_result');
    print('left_failed:');
    print('  %right = call i32 @${r.name}(%restate_t* %state, i8* %s)');
    print('  br label %got_result');
    print('got_result:');
    print('  %result = phi i32 [ %right, %left_failed ], [ 1, %0 ]');
    print('  ret i32 %result');
    print('}');
    l.gen(state, succ);
    r.gen(state, succ);
  }
}

abstract class UnaryAst extends Ast {
  UnaryAst(this.ast);
  Ast ast;
  void dump() {
    print('"$name" [label="$this"];');
    print('"$name" -> "${ast.name}";');
    ast.dump();
  }
  void alloc(State state) { ast.alloc(state); }
}

class Capturing extends UnaryAst {
  Capturing(Ast ast) : super(ast);
  int capture_register;
  // TODO: Set registers when capturing.
  void gen(State state, String succ) { ast.gen(state, succ); }
  void alloc(State state) {
    capture_register = state.captures;
    state.captures += 2;
    ast.alloc(state);
  }
  String toString() => "($ast)";
}

class Loop extends UnaryAst {
  Loop(Ast ast, this.min, this.max) : super(ast);
  Loop.asterisk(Ast ast) : super(ast);
  Loop.plus(Ast ast) : super(ast) { min = 1; }
  int min = 0;
  int max = null;  // Nullable - null means no max.
  bool get counted => min != 0 || max != null;
  int counter_register;
  String toString() {
    if (max == null) {
      if (min == 0) return "($ast)*";
      if (min == 1) return "($ast)+";
      return "($ast){$min,}";
    }
    if (min == max) return "($ast){$min}";
    return "($ast){$min,$max}";
  }
  // This is for greedy loops, so we first try to match the body of the loop,
  // and only if that fails, we try to match the successor.  When matching the
  // body, the loop itself is the successor - despite the name "Loop", we are
  // implementing this using recursion.
  void gen(State state, String succ) {
    print("define internal i32 @$name(%restate_t* %state, i8* %s) {");
    if (counted) genPreCounter(state);
    print("  %result = call i32 @${ast.name}(%restate_t* %state, i8* %s)");
    print("  %comparison = icmp eq i32 %result, 0");
    print("  br i1 %comparison, label %failed, label %ok");
    print("failed:");
    if (counted) genPostCounter();
    print("  %succ = call i32 @${succ}(%restate_t* %state, i8* %s)");
    print("  ret i32 %succ");
    print("ok:");
    print("  ret i32 1");
    print("}");
    ast.gen(state, name);
  }
  // If this loop is counted then increment the counter and check that we have
  // not exceeded the max number of iterations.
  void genPreCounter(State state) {
    print("  %gep = getelementptr %restate_t, %restate_t* %state, i64 0, i32 1, i32 ${counter_register}");
    print("  %counter = load i32, i32* %gep");
    if (max != null) {
      print("  %maxcomp = icmp eq i32 %counter, $max");
      print("  br i1 %maxcomp, label %failed, label %counter_low_enough");
      print("counter_low_enough:");
    }
    print("  %incremented = add i32 %counter, 1");
    print("  store i32 %incremented, i32* %gep");
  }
  // If this loop is counted then restore the counter (decrementing it) and
  // check that we have hit at least the min number of iterations.
  void genPostCounter() {
    print("  store i32 %counter, i32* %gep");
    if (min != 0) {
      print("  %mincomp = icmp ult i32 %counter, $min");
      print("  br i1 %mincomp, label %counter_too_low, label %counter_big_enough");
      print("counter_too_low:");
      print("  ret i32 0;");
      print("counter_big_enough:");
    }
  }
  void alloc(State state) {
    if (counted) counter_register = state.counters++;
    ast.alloc(state);
  }
}

class Parser {
  Parser(this.src);
  String src;
  int pos = 0;
  String current;

  Ast parse() {
    getToken();
    Ast ast = parseDisjunction();
    expect("");
    return ast;
  }

  Ast parseAtom() {
    if (accept("(")) {
      bool capturing = true;
      if (accept("?")) {
	expect(":");
	capturing = false;
      }
      Ast ast = parseDisjunction();
      if (capturing) ast = new Capturing(ast);
      expect(")");
      return ast;
    }
    if (current == "|" || current == ")" || current == "") return null;
    if (accept(".")) return new Dot();
    Ast ast = new Literal(current);
    accept(current);
    return ast;
  }

  Ast parseTerm() {
    Ast ast = parseAtom();
    if (ast == null) return null;
    if (accept("?")) {
      Ast empty = new EmptyAlternative();
      if (accept("?"))
	return new Disjunction(empty, ast);  // Non-greedy "?".
      return new Disjunction(ast, empty);  // Greedy "?".
    }
    if (accept("*")) return new Loop.asterisk(ast);
    if (accept("+")) return new Loop.plus(ast);
    if (accept("{")) {
      // .{2}   - exactly two matches.
      // .{2,}  - at least two matches.
      // .{2,3} - Between two and three matches.
      int min = expectNumber();
      int max = accept(",") ? acceptNumber() : min;
      if (max != null && max < min) throw "min must be <= max at $pos";
      expect("}");
      return new Loop(ast, min, max);
    }
    return ast;
  }

  Ast parseAlternative() {
    Ast ast = parseTerm();
    if (ast == null) return new EmptyAlternative();
    while (true) {
      Ast next = parseTerm();
      if (next == null) return ast;
      ast = new Alternative(ast, next);
    }
  }

  Ast parseDisjunction() {
    Ast ast = parseAlternative();
    while (accept("|")) {
      ast = new Disjunction(ast, parseAlternative());
    }
    return ast;
  }

  void getToken() {
    if (pos == src.length)
      current = "";
    else
      current = src[pos++];
  }

  void expect(String token) {
    if (token != current) throw "Expected '$token', found '$current' at $pos";
    getToken();
  }

  bool accept(String token) {
    if (token != current) return false;
    getToken();
    return true;
  }

  int expectNumber() {
    int result = acceptNumber();
    if (result == null) throw "Expected number, found '$current' at $pos";
    return result;
  }

  int acceptNumber() {
    int result = null;
    int ascii_zero = '0'.codeUnitAt(0);
    while (true) {
      if (current == "") return result;
      int code = current.codeUnitAt(0) - ascii_zero;
      if (code < 0 || code > 9) return result;
      result = result == null ? code : result * 10 + code;
      getToken();
    }
  }
}

int main(List<String> args) {
  Parser parser = new Parser(".*a.{2}e.{2,}i.*o.*u.{2,}y");
  Ast ast = parser.parse();
  if (args[0] == "dot") {
    print("Digraph G {");
    ast.dump();
    print("}");
  } else {
    print("declare i32 @match(%restate_t* %state, i8* %s)");
    State state = new State();
    ast.alloc(state);
    print("%restate_t = type { [${state.captures} x i32], [${state.counters} x i32] }");
    ast.gen(state, "match");
    print("define external i32 @grut(%restate_t* %state, i8* %s) {");
    for (int i = 0; i < state.captures; i++) {
      print("  %capture_gep$i = getelementptr %restate_t, %restate_t* %state, i64 0, i32 0, i32 $i");
      print("  store i8* 0, i8** %capture_gep$i");
    }
    for (int i = 0; i < state.counters; i++) {
      print("  %counter_gep$i = getelementptr %restate_t, %restate_t* %state, i64 0, i32 1, i32 $i");
      print("  store i32 0, i32* %counter_gep$i");
    }
    print("  %result = call i32 @${ast.name}(%restate_t* %state, i8* %s)");
    print("  ret i32 %result");
    print("}");
  }
  return 0;
}
